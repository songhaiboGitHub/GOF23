· 工厂模式：
      - 实现了创建者和调用者的分离。
      - 详细分类：
        · 简单工厂模式
        · 工厂方法模式
        · 抽象工厂模式


· 面向对象设计的基本原则：
      - OCP（开闭原则，Open-Closed principle）： 一个软件的实体应当对扩展开放，对修改关闭。
      - DIP（依赖倒转原则，Dependence Inversion Principle）： 要针对接口编程，不要针对实现编程。
      - LOD（迪米特法则，Law of Demeter）： 只与你直接的朋友通信，而避免和陌生人通信。


· 核心本质：
      - 实例化对象，用工厂方法代替new操作。
      - 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。


· 工厂模式：
      - 简单工厂模式：
        · 用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）
      - 工厂方法模式：
        · 用来生产同一等级结构中的固定产品。（支持增加任意产品）
      - 抽象工厂模式：
        · 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）


· 工厂方法模式要点：
      - 为了避免简单工厂模式的缺点，不完全满足OCP。
      - 工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了
      相同接口的工厂类。


· 简单工厂模式和工厂方法模式PK:
      - 结构复杂度
           从这个角度比较，显然简单工厂模式要占优势。简单工厂模式只需一个工厂类，而工厂方法模式的工厂类随着产品类个数量增加而增加，这无疑会
           使类的个数越来越多，从而增加了结构的复杂程度。
      - 代码复杂度
           代码复杂度和结构复杂度是一对矛盾，既然简单工厂模式在结构方面相对简洁，那么他在代码方面肯定是比工厂方法模式复杂的，简单工厂模式的工
           厂类随着产品类的增加需要增加很多方法或代码，而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。
      - 客户端编程难度
           工厂方法模式虽然在工厂类结构中引入了接口从而满足了OCP，但是在客户端编码中需要对工厂类进行实例化，而简单工厂模式的工厂类是个静态类，
           在客户端无需实例化，这无疑是个吸引人的优点。
   · 根据设计理论建议：工厂方法模式占优势。但实际上，我们一般都用简单工厂模式。


· 抽象工厂模式
      - 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）
      - 抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。


· 工厂模式要点：
      - 简单工厂模式（静态工厂模式）
          · 虽然不符合设计原则（OCP开闭原则），但实际使用最多。
      - 工厂方法模式
          · 不修改已有类的前提下，通过增加新的工厂类实现扩展。
      - 抽象工厂模式
          · 不可以增加产品，可以增加产品族。


· 应用场景
      - JDK中Calendar的getInstance方法
      - JDBC中Connection对象的获取
      - Hibernate中SessionFactory创建Session
      - Spring中IOC容器创建管理bean对象
      - XML解析时的DocumentBuderFactory创建解析器对象
      - 反射中Class对象的newInstance()