· 原型模式场景：
      - 思考一下：克隆技术是怎么样的过程？克隆羊多利大家还记得吗？
      - JavaScript语言中的，继承怎么实现？那里面也有prototype，大家还记得吗？

· 原型模式：
      - 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
      - 就是Java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点。
      - 优势有：效率高（直接克隆，避免了重新执行构造过程步骤）。
      - 克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影
      响原型对象。然后，在修改克隆对象的值。


· 原型模式实现：
      - Cloneable接口和clone方法。
      - Prototype模式中实现起来最困难的地方就是内存复制操作，所幸在Java中提供了clone()方法替我们做了绝大部分事情。
      - 利用序列化和反序列化技术实现深克隆！


· 短时间大量创建对象时，原型模式和普通new方式效率测试
      - 测试普通new方式创建对象和clone方式创建对象的效率差异！如果需要短时间创建大量对象，并且new的过程比较耗时。则可以考虑使用原型模式！


· 开发中的应用场景
      - 原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。
           · spring中bean的创建实际就是两只：单例模式和原型模式。（当然，原型模式需要和工厂模式搭配起来）


· 创建型模式：都是用来帮助我们创建对象的！
      - 单例模式
          · 保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。
      - 工厂模式
          · 简单工厂模式
              - 用来生产同一等级结果中的任意产品。（对于新增的产品，需要修改已有代码）
          · 工厂方法模式
              - 用来生产同一等级结构中的固定产品。（支持增加任意产品）
          · 抽象工厂模式
              - 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）
      - 建造者模式
          · 分离了对象子组件的单独构造（由builder来负责）和装配（由Director负责）。从而可以构造出复杂的对象
      - 原型模式
          · 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式
